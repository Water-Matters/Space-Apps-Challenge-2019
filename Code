import numpy as np

import holoviews as hv

from osgeo import gdal

import matplotlib as mpl

import matplotlib.pyplot as plt

from numpy import ma

from matplotlib import cbook

from matplotlib.colors import Normalize

---------------------------------------------------------------------------
ModuleNotFoundError                       Traceback (most recent call last)
<ipython-input-4-ca581c6d18f3> in <module>()
      1 import numpy as np
----> 2 import holoviews as hv
      3 from osgeo import gdal
      4 import matplotlib as mpl
      5 import matplotlib.pyplot as plt

ModuleNotFoundError: No module named 'holoviews'

import numpy as np

import holoviews as hv

from osgeo import gdal

import matplotlib as mpl

import matplotlib.pyplot as plt

from numpy import ma

from matplotlib import cbook

from matplotlib.colors import Normalize

​

gv.extension('bokeh', 'matplotlib')

---------------------------------------------------------------------------
ModuleNotFoundError                       Traceback (most recent call last)
<ipython-input-3-68a53cc97812> in <module>()
      1 import numpy as np
----> 2 import holoviews as hv
      3 from osgeo import gdal
      4 import matplotlib as mpl
      5 import matplotlib.pyplot as plt

ModuleNotFoundError: No module named 'holoviews'

src_ds = gdal.Open( "Rome-30m-DEM.tif" )

data = src_ds.ReadAsArray()

---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-2-5f907d9b34df> in <module>()
----> 1 src_ds = gdal.Open( "Rome-30m-DEM.tif" )
      2 data = src_ds.ReadAsArray()

NameError: name 'gdal' is not defined

class MidPointNorm(Normalize):    

    def __init__(self, midpoint=0, vmin=None, vmax=None, clip=False):

        Normalize.__init__(self,vmin, vmax, clip)

        self.midpoint = midpoint

​

    def __call__(self, value, clip=None):

        if clip is None:

            clip = self.clip

​

        result, is_scalar = self.process_value(value)

​

        self.autoscale_None(result)

        vmin, vmax, midpoint = self.vmin, self.vmax, self.midpoint

​

        if not (vmin < midpoint < vmax):

            raise ValueError("midpoint must be between maxvalue and minvalue.")       

        elif vmin == vmax:

            result.fill(0) # Or should it be all masked? Or 0.5?

        elif vmin > vmax:

            raise ValueError("maxvalue must be bigger than minvalue")

        else:

            vmin = float(vmin)

            vmax = float(vmax)

            if clip:

                mask = ma.getmask(result)

                result = ma.array(np.clip(result.filled(vmax), vmin, vmax),

                                  mask=mask)

​

            # ma division is very slow; we can take a shortcut

            resdat = result.data

​

            #First scale to -1 to 1 range, than to from 0 to 1.

            resdat -= midpoint            

            resdat[resdat>0] /= abs(vmax - midpoint)            

            resdat[resdat<0] /= abs(vmin - midpoint)

​

            resdat /= 2.

            resdat += 0.5

            result = ma.array(resdat, mask=result.mask, copy=False)                

​

        if is_scalar:

            result = result[0]            

        return result

​

    def inverse(self, value):

        if not self.scaled():

            raise ValueError("Not invertible until scaled")

        vmin, vmax, midpoint = self.vmin, self.vmax, self.midpoint

​

        if cbook.iterable(value):

            val = ma.asarray(value)

            val = 2 * (val-0.5)  

            val[val>0]  *= abs(vmax - midpoint)

            val[val<0] *= abs(vmin - midpoint)

            val += midpoint

            return val

        else:

            val = 2 * (val - 0.5)

            if val < 0: 

                return  val*abs(vmin-midpoint) + midpoint

            else:

                return  val*abs(vmax-midpoint) + midpoint

​

Modify fdata using equations here!

Color palette will change in order to visualize the sea level rise(work in progress)

This example includes the topography of Rome with a higher sea level

increase = 50

norm = MidPointNorm(midpoint=50+increase)

fig, ax = plt.subplots(figsize=(10, 8))

ax.imshow(fdata, norm=norm, cmap='tab20c', aspect='auto')

<matplotlib.image.AxesImage at 0x7f54eb560b00>

